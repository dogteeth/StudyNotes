#### Prepare for segue 什麼時候被呼叫？
When a segue is triggered – perhaps through a button press or a table view selection – the prepare(for:) method will be called on your view controller, at which point you can configure your destination view controller by setting some properties.


#### segue有四種
- show : 以全營幕的方式程現。（支援導覽列控制器）
- show detail ： 如果視圖是分割成左右兩半，會出現在右方的視圖。若視圖非分割狀態，則會以全營幕出現。（不支援導覽列控制器）
- present modally：可設成全營幕，也可以是個矩型在中間。或是由下往上滑動。
- present as popover：在大營幕是pop up小視窗。在小營幕則是全營幕。


#### Segue Perform
- prepare for segue
```Swift
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
       
        if segue.destination is CaseDetailTVC { //如果segue的目的地是XXXX
            let vc = segue.destination as? CaseDetailTVC //做一個vc, 把它指到目的地，同時安排要丟到vc的變數有哪些，先指定好。
            vc?.item = itemForSegue
            vc?.items = items
            vc?.index = indexForSegue
        }
    }
```
- perform segue
```Swift
 performSegue(withIdentifier: "listToCaseDetail", sender: self)  //以 segue的ID來做啟動，perform哪一個segue ID.

```


#### strong, weak 與 unowned
[資料來源](https://www.appcoda.com.tw/memory-management-swift/)

- 與 Swift 記憶體管理的 Automatic Reference Counting （自動參考計數機制, ARC）有關。
- Reference Counting 是以一項技術，是將資源（例如物件、記憶體或磁盤空間等）被參考的次數保存起來。簡單來說，ARC 可以把參考儲存到記憶體中，並自動清除沒有在使用的參考。
- Reference Counting 僅適用於類別 (class) 的實例 (instance)，而不適用於結構 (structures) 和枚舉 (enumerations)，因為他們兩個都是數值型別 (Value Type)，而不是參考型別 (Reference Type)。
- Swift 的記憶體管理會一直運作，你不需要自己去考慮記憶體管理的問題。當實例不再被使用時，ARC 會自動釋放所佔用的記憶體。
- 每當你要初始化 init() 一個類別時，ARC 會自動配置記憶體來儲存資料；更具體來說，就是一部份的記憶體配置了給實例，並同時在屬性配置了數值，所以當不再需要實例時，deinit() 就會被呼叫，而 ARC 會將此實例的記憶體空間釋出。
- ![arc-strong-weak-unowned](https://user-images.githubusercontent.com/18608853/117527448-bd744600-affe-11eb-870c-713f5b7c141d.png)


#### 存取控制
- 檔案有兩種，一種叫source, 我們寫的程式就是source。另外一個是module，import UIKit就是module
- open與public: 所有的類別，方法，屬性都是可以存取。
- internail: 同一個module下才可以存取。這是預設的層級。所有的屬性和方法預設都是internal
- fileprivate: 同一個source下才可以存取。
- private: 只能在同一個scope下才可以存取。
- final: 加入final的class, 不能被繼承

#### Struct 與 Class的差別
- struct不能繼承
- struct在傳遞時，永遠都是用複製的方式進行。

- class宣告時，要同時設定 init
```Swift
class Baby {
  var age : Int
  
  init() {
    age = 9
  }
}
```

- class在繼承時，有兩個要求：
  - 屬性的初始，必需在當初宣告屬性的類別裹進行。
  - 子類別必需先宣告自己的屬性後，才能宣告父類別的屬性。
```Swift
class SuperBaby : Baby {
  var magic : String
    init(magic: String){
      self.magic = magic
      super.init()
    }
}
```


#### 類別初始化的幾個重點：
- Designated：
  - 可選值可以不用初始化，如果不初始化值，系統預設用nil初始化它。
  - 如果類中含有非可選的儲存屬性並且沒有預設值，則必須實現指定初始化方法，並且初始化該屬性。
  - 如果子類沒有自己的初始化方法，系統預設使用父類的初始化方法，一旦有了自己的初始化方法，或者重寫了父類的初始化方法，則父類的所有初始化不能被子類呼叫。
  - 你可以給子類新增和父類相同的初始化方法，但需要加上override修飾。
- convenience：
  - 在同一個類，使用convenience修飾的初始化方法必須呼叫一個其他初始化方法。
  - convenience必須最終呼叫一個指定的初始化方法。
  - 重寫父類的convenience修飾的方便初始化方法，不需要加override關鍵字。
- required:
  - 子類必須重寫父類用required修飾的方法。
  - 可以和convenience組合使用。




#### 記憶體管理
- 物件還需要使用時，就保留在記憶中。
- reference counting。有被使用就會加1。


#### 屬性監視器
- 想要知道value有沒有變更，可以使用 willSet, didSet這兩個功能。
- willSet will be called before the value changed, and will use the new value as a tool.
- didSet will be called after the value changed, adn will use the old value as a tool.
- willSet, didSet can use as a monitor, to do sometiong when value changes.

- lazy var, only will be initialized, when someone call it.

```Swift
var age: Int = 0 {
  willSet {
    //do something with the new value before this value is changed.
  }
  didSet {
    //do something with the old value after this value is changed.
  }
}

```
#### StoryBoard View Recyle
- viewDidLoad() : 所有的畫面元件都己經載入完畢。在記憶體充足的情況下，此階段只會在初始化後執行一次。只需執行一次的程式，放在這裹。
- viewWillAppear() : 元件己完成初始化，在顯示畫面前的準備。在viewDidLoad()之後，或是user 回到此畫面時，元件在顯示前做調整。
- viewDidAppear() : 畫面load完後才執行的程式。譬如：動畫。
- viewWillDisppear() : 畫面準備要消失了，這時候user己無法對畫面做任何動作。可將儲存使用者操作設定或結果，放在這裹。
- viewDidDisppear() : 此階段畫面己消失，但此時仍可以進行程式的執行。執行後的結果，會再下次畫面出現時顯示。



#### CGPoint的延伸公式判斷
[link](https://gist.github.com/akhilcb/8d03f1f88f87e996aec24748bdf0ce78)

#### static, public 的差別
[reference](https://medium.com/@jerrywang0420/access-control-教學-swift-3-ios-4d93ee567eb0) 
- public(公共的)：
- protected(受保護的)： 
- private(私有的)：
- static(靜態)：


#### Nib & Xib
- NIBs and XIBs are files that describe user interfaces, and are built using Interface Builder. In fact, the acronym "NIB" comes from "NeXTSTEP Interface Builder", and "XIB" from "Xcode Interface Builder". NIBs and XIBs are effectively the same thing: XIBs are newer and are used while you're developing, whereas NIBs are what get produced when you create a build.


#### lhs, rhs
- lhs, left hand side of assignment
- rhs, right hand side of assignment
