#### required/super init
- override init(frame: CGRect) is used when you create the view  programmatically.
- required init?(coder: NSCoder) is used when the view is created from storyboard/xib.
- When you override an initializer such as init(frame: CGRect), you do it against a designated initializer, i.e. the principal initializer responsible for creating an object programmatically. According to rules, you must call super.init before performing any additional init actions.

- init 有五種。
    -  init()
    -  convenience init()
    -  required init()
    -  override init()
    -  super init()

- 當物件建立時，將透過 initializer 進行相關的初始動作，確保物件所有的 stored property 都完成初始。然而物件的屬性除了在自己的類別裡宣告外，也可能從父類別繼承。為了保證程式的安全性，確保屬性已正確初始後才使用，Swift 訂定 2 個一定要遵守的原則，所有的機制，所有的檢查都以此原則為中心思想。
    - 原則一: 屬性的初始，必須在當初宣告屬性的類別裡進行。
    - 原則二: 子類別得先完成自己屬性的初始後，才能進行父類別屬性的初始。

#### Prepare for segue 什麼時候被呼叫？
When a segue is triggered – perhaps through a button press or a table view selection – the prepare(for:) method will be called on your view controller, at which point you can configure your destination view controller by setting some properties.


#### segue有四種
- show : 以全營幕的方式程現。（支援導覽列控制器）
- show detail ： 如果視圖是分割成左右兩半，會出現在右方的視圖。若視圖非分割狀態，則會以全營幕出現。（不支援導覽列控制器）
- present modally：可設成全營幕，也可以是個矩型在中間。或是由下往上滑動。
- present as popover：在大營幕是pop up小視窗。在小營幕則是全營幕。


#### Segue Perform
- prepare for segue
```Swift
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
       
        if segue.destination is CaseDetailTVC { //如果segue的目的地是XXXX
            let vc = segue.destination as? CaseDetailTVC //做一個vc, 把它指到目的地，同時安排要丟到vc的變數有哪些，先指定好。
            vc?.item = itemForSegue
            vc?.items = items
            vc?.index = indexForSegue
        }
    }
```
#### Dissmiss自己
```Swift
navigationController?.popViewController(animated: true)
        
```


- perform segue
```Swift
 performSegue(withIdentifier: "listToCaseDetail", sender: self)  //以 segue的ID來做啟動，perform哪一個segue ID.

```
#### String to Array
- 運用stringA.components(separatedBy: ",") 即可以逗號分開，把字串變成array

```Swift
let stringA = "台北,內湖,三民主義"
var stringArray: [String] = []

stringArray = stringA.components(separatedBy: ",")

print(stringA)
print(stringArray)
print(stringArray.count)

```

#### 將Array裹的item變成獨立不重覆
- 將array轉成set再轉回array
- 因為set不能有重覆值，所以轉成set就會自動把重覆的值拿掉了。

```Swift
let stringA:[String] = ["台北", "內湖", "西遊記"]
let stringB:[String] = ["apple", "內湖", "佐丹努"]
let stringC =  stringA +  stringB
print(stringC)

let unique = Array(Set(stringC))

print(unique)
```
#### 在array裹尋找值
- if arrayA.contains(keywordA) { }

```Swift
let arrayA = ["台北", "內湖", "西遊記"]
let keywordA = "台北"
let keywordB = "apple"

if arrayA.contains(keywordA) {
    print("contains a is yes")
} else {
    print("contains a is no")
}

if arrayA.contains(keywordB) {
    print("contains b is yes")
} else {
    print("contains b is no")
}

```


#### strong, weak 與 unowned
[資料來源](https://www.appcoda.com.tw/memory-management-swift/)

- 與 Swift 記憶體管理的 Automatic Reference Counting （自動參考計數機制, ARC）有關。
- Reference Counting 是以一項技術，是將資源（例如物件、記憶體或磁盤空間等）被參考的次數保存起來。簡單來說，ARC 可以把參考儲存到記憶體中，並自動清除沒有在使用的參考。
- Reference Counting 僅適用於類別 (class) 的實例 (instance)，而不適用於結構 (structures) 和枚舉 (enumerations)，因為他們兩個都是數值型別 (Value Type)，而不是參考型別 (Reference Type)。
- Swift 的記憶體管理會一直運作，你不需要自己去考慮記憶體管理的問題。當實例不再被使用時，ARC 會自動釋放所佔用的記憶體。
- 每當你要初始化 init() 一個類別時，ARC 會自動配置記憶體來儲存資料；更具體來說，就是一部份的記憶體配置了給實例，並同時在屬性配置了數值，所以當不再需要實例時，deinit() 就會被呼叫，而 ARC 會將此實例的記憶體空間釋出。
- ![arc-strong-weak-unowned](https://user-images.githubusercontent.com/18608853/117527448-bd744600-affe-11eb-870c-713f5b7c141d.png)


#### 存取控制
- 檔案有兩種，一種叫source, 我們寫的程式就是source。另外一個是module，import UIKit就是module
- open與public: 所有的類別，方法，屬性都是可以存取。
- internail: 同一個module下才可以存取。這是預設的層級。所有的屬性和方法預設都是internal
- fileprivate: 同一個source下才可以存取。
- private: 只能在同一個scope下才可以存取。
- final: 加入final的class, 不能被繼承

---

- Open 存取： 擁有最高的存取權限，即最少的限制，可被同一個 module 的任何檔案存取，或一個不同的 module 存取。

- public 存取： 可被同一個 module 的任何檔案存取，或一個不同的 model 存取。Classes 擁有 public 存取或更多限制的存取層級，只能在其定義的 module 為 subclasses。Classes 的成員擁有 public 存取或更多限制存取層級，只能在其定義的 module 的 subclasses 覆載。

- Internal 存取： 可被其定義的 module 內的任何 sourcr file 所存取，但無法被外部 module 的任何檔案存取。當定義一個應用程式或 framework 的內部結構時，通常使用 internal 存取。

- File-private 存取： 存取限制為其自定義的 source file。當在整份文件中使用這些詳細內容時，使用 file-private 存取來隱藏特定功能的實現細節。

- Private 存取： 最低存取權限，即最多限制。宣告區塊和同一份檔案的擴展宣告才可存取。




### Struct 與 Class的差別

- struct 不用init, class要init


- struct不能繼承
- struct在傳遞時，永遠都是用複製的方式進行。
- class裹宣告的值是mutable，但struct是immutable, 縱使是var

- class宣告時，要同時設定 init
```Swift
class Baby {
  var age : Int
  
  init() {
    age = 9
  }
}
```

- class在繼承時，有兩個要求：
  - 屬性的初始，必需在當初宣告屬性的類別裹進行。
  - 子類別必需先宣告自己的屬性後，才能宣告父類別的屬性。
```Swift
class SuperBaby : Baby {
  var magic : String
    init(magic: String){
      self.magic = magic
      super.init()
    }
}
```


#### 類別初始化的幾個重點：
- Designated：
  - 可選值可以不用初始化，如果不初始化值，系統預設用nil初始化它。
  - 如果類中含有非可選的儲存屬性並且沒有預設值，則必須實現指定初始化方法，並且初始化該屬性。
  - 如果子類沒有自己的初始化方法，系統預設使用父類的初始化方法，一旦有了自己的初始化方法，或者重寫了父類的初始化方法，則父類的所有初始化不能被子類呼叫。
  - 你可以給子類新增和父類相同的初始化方法，但需要加上override修飾。
- convenience：
  - 在同一個類，使用convenience修飾的初始化方法必須呼叫一個其他初始化方法。
  - convenience必須最終呼叫一個指定的初始化方法。
  - 重寫父類的convenience修飾的方便初始化方法，不需要加override關鍵字。
- required:
  - 子類必須重寫父類用required修飾的方法。
  - 可以和convenience組合使用。




#### 記憶體管理
- 物件還需要使用時，就保留在記憶中。
- reference counting。有被使用就會加1。


#### 屬性監視器
- 想要知道value有沒有變更，可以使用 willSet, didSet這兩個功能。
- willSet will be called before the value changed, and will use the new value as a tool.
- didSet will be called after the value changed, adn will use the old value as a tool.
- willSet, didSet can use as a monitor, to do sometiong when value changes.

- lazy var, only will be initialized, when someone call it.

```Swift
var age: Int = 0 {
  willSet {
    //do something with the new value before this value is changed.
  }
  didSet {
    //do something with the old value after this value is changed.
  }
}

```
#### StoryBoard View Recyle
- viewDidLoad() : 所有的畫面元件都己經載入完畢。在記憶體充足的情況下，此階段只會在初始化後執行一次。只需執行一次的程式，放在這裹。
- viewWillAppear() : 元件己完成初始化，在顯示畫面前的準備。在viewDidLoad()之後，或是user 回到此畫面時，元件在顯示前做調整。
- viewDidAppear() : 畫面load完後才執行的程式。譬如：動畫。
- viewWillDisppear() : 畫面準備要消失了，這時候user己無法對畫面做任何動作。可將儲存使用者操作設定或結果，放在這裹。
- viewDidDisppear() : 此階段畫面己消失，但此時仍可以進行程式的執行。執行後的結果，會再下次畫面出現時顯示。



#### CGPoint的延伸公式判斷
[link](https://gist.github.com/akhilcb/8d03f1f88f87e996aec24748bdf0ce78)

#### static, public 的差別
[reference](https://medium.com/@jerrywang0420/access-control-教學-swift-3-ios-4d93ee567eb0) 
- public(公共的)：
- protected(受保護的)： 
- private(私有的)：
- static(靜態)：

#### Nib & Xib
- NIBs and XIBs are files that describe user interfaces, and are built using Interface Builder. In fact, the acronym "NIB" comes from "NeXTSTEP Interface Builder", and "XIB" from "Xcode Interface Builder". NIBs and XIBs are effectively the same thing: XIBs are newer and are used while you're developing, whereas NIBs are what get produced when you create a build.


#### lhs, rhs
- lhs, left hand side of assignment
- rhs, right hand side of assignment


#### navigationItem title
- 回上頁的文字，是屬於上一個頁面的。所以需要在上頁設定。
```Swift
        //這一頁的title 文字
        navigationItem.title = ("\(cityTitle): \(totalNum)件")
        
        //下一頁看到的回上頁的文字。
        let backItem = UIBarButtonItem()
        backItem.title = "\(cityTitle)"
        navigationItem.backBarButtonItem = backItem
```

#### Swift 判斷
[來源](https://www.cnswift.org/basic-operators)


#### 拷貝
- 使用UIPasteboard
- [來源](https://maximbilan.medium.com/ios-how-to-use-uipasteboard-b1619d7c8f61)

```swift
guard let safeItem = item else {return}
let address = Helper.assembleItemInfo(item: safeItem, assembleOutput: 6)
UIPasteboard.general.string = address
```
#### get the first n character of a string
```Swift
let str = "SampleText"
let result = String(str.characters.prefix(5)) // result = "Sampl"
```

#### return a uppercase of a letter
```Swift
yourLetter.uppercased()  
```

#### async
- Concurrency in Swift means allowing multiple pieces of code to run at the same time. 
- asynchronous：異步 -  not happening or done at the same time or speed
- concurrency：並發 - the fact of two or more events or circumstances happening or existing at the same time.

```Swift
func fetchImages() async throws -> [UIImage] {
    // .. perform data request
}
```
- async replace closure.
```Swift
func fetchImages(completion: (Result<[UIImage], Error>) -> Void) {
    // .. perform data request
}

func fetchImages(completion: ([UIImage]?, Error?) -> Void) {
    // .. perform data request
}
```

- Await is the keyword to be used for calling async methods. You can see them as best friends in Swift as one will never go without the other.

```Swift
do {
    let images = try await fetchImages()
    print("Fetched \(images.count) images.")
} catch {
    print("Fetching images failed with error \(error)")
}
```

#### lazy
- lazy propertiy is initialized only when it is accessed for the first time.
